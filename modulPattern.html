<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Module Pattern</title>
</head>
<p id="target"></p>

<body>
    <script>

        // 1⭐⭐⭐ A module is a construct somewhat similar to a singleton class. 
        // It has only one instance and exposes its members, 
        // but it doesn’t have any kind of internal state.

        // Module is created as an IIFE


        // 2⭐⭐⭐ lets create a module with a private function inside
        // const Formatter = (function(){
        //     const log = (message) => console.log(`[${Date.now()}] Logger: ${message}`)
        // })()

        // if we try to run this in the console, we get an error
        // Formatter.log("Hello"); // Uncaught TypeError: Cannot read properties of undefined (reading 'log')

        // So, now we know that accessing a module is actually accessing whatever it returns.


        // 3⭐⭐⭐ Here the log function is a private one. 
        // It can be accessed from within the module and other functions inside can execute it. Let’s try!
        // const Formatter = (function () {
        //     const log = (message) => console.log(`[${Date.now()}] Logger: ${message}`)

        //     const makeUpperCase = (text) => {
        //         log("Making Upper Case")
        //         return text.toUpperCase()
        //     }
        // })()


        // 4⭐⭐⭐ Exposing a module

        // Do not return a single function (although it is possible), return an object with it!
        // const Formatter = (function () {
        //     const log = (message) => console.log(`[${Date.now()}] Logger: ${message}`)

        //     const makeUpperCase = (text) => {
        //         log("Making Upper Case")
        //         return text.toUpperCase()
        //     }
        //     return { makeUpperCase }
        // })()

        // console.log(Formatter.makeUpperCase("sodiq")) // [1753117107165] Logger: Making Upper Case /n SODIQ


        // 5⭐⭐⭐ Modules can house not only functions, but arrays, objects and primitives as well.
        // const Formatter = (function () {
        //     let timesRun = 0;
        //     const log = (message) => console.log(`[${Date.now()}] Logger: ${message}`)

        //     const setTimesRun = () => {
        //         log("Setting times run")
        //         timesRun++
        //     }

        //     const makeUpperCase = (text) => {
        //         log("Making Upper Case")
        //         setTimesRun()
        //         console.log("timesRun in makeUpperCaser fn " + timesRun)
        //         return text.toUpperCase()
        //     }
        //     return { makeUpperCase, timesRun }
        // })()

        // lets execute the return object contents
        // console.log(Formatter.makeUpperCase("sodiq")) // SODIQ
        // console.log(Formatter.timesRun) // 0 

        // As expected, 0 is shown. But note that this can be overwritten from outside.

        // Formatter.timesRun = 10
        // console.log(Formatter.timesRun) // 10

        // This shows that everything publicly exposed can be changed from the outside. 
        // This is one of the biggest module pattern drawbacks.



        // 6⭐⭐⭐ Reference types works differently. 
        // Here, you can define it and it will be populated as you go.
        // const Formatter = (function () {
        //     const timesRun = [];
        //     const log = (message) => console.log(`[${Date.now()}] Logger: ${message}`)


        //     const makeUpperCase = (text) => {
        //         log("Making Upper Case")
        //         timesRun.push(null)
        //         return text.toUpperCase()
        //     }
        //     return { makeUpperCase, timesRun }
        // })()

        // console.log(Formatter.makeUpperCase("sodiq")) // SODIQ
        // console.log(Formatter.makeUpperCase("sodiq")) // SODIQ
        // console.log(Formatter.makeUpperCase("sodiq")) // SODIQ
        // console.log(Formatter.makeUpperCase("sodiq")) // SODIQ
        // console.log(Formatter.timesRun.length) // 4



        // 7⭐⭐⭐ Declaring module dependencies eg DOM
        // I like to treat modules as closed entities. 
        // Meaning, they reside within themselves and nothing more is needed for them to exist. 
        // But sometimes you may want to work with, for example, DOM or window global object.


        //To achieve that, module may have dependencies. 
        // Let’s try to write a function that will write a message to our requested HTML element.
        // const Formatter = (function () {
        //     const log = (message) => console.log(`[${Date.now()}] Logger: ${message}`)

        //     const makeUpperCase = (text) => {
        //         log("Making Upper Case")
        //         return text.toUpperCase()
        //     }

        //     const writeToDom = (selector, message) => {
        //         document.querySelector(selector).textContent = message
        //     }

        //     return { makeUpperCase, writeToDom }
        // })()

        // Formatter.writeToDom("#target", "Hello Manager")

        // It works out of the box (assuming that we have an element with id target in our DOM). 
        // Sounds great, but document is available only when the DOM is accessible.
        // Running the code on a server would produce an error.
        // So, how to make sure that we’re good to go?

        // One of the options is to check whether document exists.
        // const writeToDom = (selector, message) => {
        //     if (!!document && "querySelector" in document) {
        //         document.querySelector(selector).textContent = message
        //     }
        // }
        // And this pretty much takes care of everything, but I don’t like it. 
        // Now the module really depends on something from the outside. 
        // It’s „I will go only if my friend will go too” scenario. It has to be like this?
        // // No, of course not. 
        // // We can declare our module’s dependencies and inject them as we go.

        const Formatter = (function () {
            const log = (message) => console.log(`[${Date.now()}] Logger: ${message}`)

            const makeUpperCase = (text) => {
                log("Making Upper Case")
                return text.toUpperCase()
            }

            const writeToDom = (selector, message) => {
                document.querySelector(selector).textContent = message
            }

            return { makeUpperCase, writeToDom }
        })()

    </script>
</body>

</html>